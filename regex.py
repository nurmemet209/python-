
import re
str = "45*12321"

print(re.match(r"^\d{2}[*](\d+(\.\d+)?)$", str))
#match 函数字符串开始位置开始匹配开始位置不能匹配直接返回None
obj=re.match(r'[A-Za-z0-9]+', '45我lsdkflsd你fds')
print(obj.group())

# 替换匹配的字段,替换所有汉子和括号([])
print(re.sub(r"[(\u4e00-\u9fa5)(\[)(\])]",'','Ghost [古思特]'))

# ^\d{2}[*]\d+$
# ^表示字符串的开始位置开始匹配，开始位置都不匹配，直接返回空
# \d{2}表示两个数字字符
# [*]表示匹配括号里面的任意字符
# \d 表示匹配一个数字字符
# +表示匹配前面的表达式一次或多次

# ^\d+(\.\d+)?$ 匹配不带正负符号的实数
# ^表示字符串开始位置匹配
# \d 表示一个数字字符
# +表示多次或一次匹配前面的表达式，例如(999)
# ()表示运算符优先级
# \. 表示一个.(前面的\是用来转移的，否则正则表达式中.是有其他含义)
# ? 表示匹配前面的表达零次或一次

# ^[-+]?\d+(\.\d+)?$ 匹配带或不带正负符号的实
# 这个表达式含义跟前面差不多,[]表示匹配括号里面的字符
# ?表示匹配一次或零次

# Chapter [1-9][0-9]?
# 上面的表达式会匹配 sdadas Chapter 23 sdasdsadsa,输出 Chapter 23
# 它会从给定的字符串里面任意位置寻找 Chapter [1-9][0-9]? 表达式对应的部分

# http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html

